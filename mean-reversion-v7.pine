// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// © mean-reversion-v7 — Standalone Mean Reversion Oscillator (Timeframe Adaptive Periods)

//@version=6
indicator("MR Mean-Reversion V7", shorttitle="MR-Rev V7", overlay=false, precision=4,
     max_labels_count=1)

// ══════════════════════════════════════════════════════════════════════════════
//  CORE SETTINGS
//  Algorithm: WMA baseline, ATR-normalized deviation, EMA smoothing, ohlc4.
//  Periods auto-scale by timeframe so the indicator measures the same calendar
//  window (~50 trading days) regardless of chart resolution.
// ══════════════════════════════════════════════════════════════════════════════

string tradingStyle = input.string("Neutral", "Trading Style",
     options=["Very Aggressive","Aggressive","Neutral","Conservative","Very Conservative"],
     tooltip="Controls signal dot sensitivity.",
     group="1. SETTINGS")

string srcInput     = input.string("ohlc4", "Source",
     options=["close","hlc3","hl2","ohlc4"],
     group="1. SETTINGS")

string baseMAType   = input.string("WMA", "Baseline MA",
     options=["SMA","EMA","WMA","DEMA","TEMA","HullMA"],
     group="1. SETTINGS")

int    baseLen      = input.int(50, "Baseline Length (Daily reference)", minval=2, maxval=500,
     tooltip="Baseline period calibrated for Daily chart. Auto-scaled for other timeframes when TF Adaptive is ON.",
     group="1. SETTINGS")
int    atrPeriod    = input.int(50, "ATR Period (Daily reference)", minval=2, maxval=500,
     tooltip="ATR period calibrated for Daily chart. Auto-scaled for other timeframes when TF Adaptive is ON.",
     group="1. SETTINGS")
int    smoothLen    = input.int(9, "Smooth Length (0=none)", minval=0, maxval=100,
     tooltip="EMA smoothing. NOT scaled by timeframe — faster TFs are naturally noisier.",
     group="1. SETTINGS")

// ══════════════════════════════════════════════════════════════════════════════
//  TIMEFRAME ADAPTIVE SCALING
// ══════════════════════════════════════════════════════════════════════════════

bool  tfAdaptive   = input.bool(true, "TF Adaptive Periods",
     tooltip="Auto-scales baseline & ATR periods so all timeframes cover ~50 trading days. Disable to use fixed bar counts.",
     group="2. TF SCALING")
float tradingHrs   = input.float(6.5, "Trading Hours/Day", minval=1.0, maxval=24.0, step=0.5,
     tooltip="Trading hours per day for your market. US Stocks=6.5, Crypto/Forex=24.0. Affects TF scaling accuracy.",
     group="2. TF SCALING")
int   maxPeriod    = input.int(500, "Max Period (cap)", minval=50, maxval=2000, step=50,
     tooltip="Maximum lookback bars after scaling. Prevents excessive computation on very low timeframes.",
     group="2. TF SCALING")

// ══════════════════════════════════════════════════════════════════════════════
//  SCALING
// ══════════════════════════════════════════════════════════════════════════════

float gain = input.float(0.3215, "Gain", minval=0.01, step=0.01,
     tooltip="Amplitude multiplier. Calibrated on Daily TSLA (R=0.9919).",
     group="3. SCALING")
float bias = input.float(0.0404, "Bias", step=0.01,
     tooltip="Vertical offset. Calibrated on Daily TSLA (R=0.9919).",
     group="3. SCALING")

// ══════════════════════════════════════════════════════════════════════════════
//  SIGNALS & NOISE SUPPRESSION
// ══════════════════════════════════════════════════════════════════════════════

int   noiseSup     = input.int(30, "Noise Suppression", minval=0, maxval=50, step=10,
     tooltip="Suppresses weaker signals within N bars of stronger ones. 0 = off.",
     group="4. SIGNALS")

// ══════════════════════════════════════════════════════════════════════════════
//  DISPLAY
// ══════════════════════════════════════════════════════════════════════════════

bool  showTable    = input.bool(true, "Show Settings Table", group="5. DISPLAY")
string tblPos      = input.string("Top Right", "Table Position",
     options=["Top Left","Top Right","Bottom Left","Bottom Right"], group="5. DISPLAY")

// ══════════════════════════════════════════════════════════════════════════════
//  AUTO-FIT DIAGNOSTIC (optional)
// ══════════════════════════════════════════════════════════════════════════════

bool  showAutoFit  = input.bool(false, "Enable Auto-Fit Diagnostic", group="6. AUTO-FIT (optional)")
float origPlot     = input.source(close, "Original Plot",
     tooltip="Point this at the IA-Mean-Reversion plot for comparison.",
     group="6. AUTO-FIT (optional)")
int   corrWindow   = input.int(300, "Correlation Window", minval=50, maxval=5000, step=50,
     group="6. AUTO-FIT (optional)")
bool  showOrig     = input.bool(false, "Show Original Overlay", group="6. AUTO-FIT (optional)")

// ══════════════════════════════════════════════════════════════════════════════
//  TRADING STYLE → threshold levels
// ══════════════════════════════════════════════════════════════════════════════

float upperDotLvl = switch tradingStyle
    "Very Aggressive" => 0.20
    "Aggressive"      => 0.35
    "Neutral"         => 0.50
    "Conservative"    => 0.65
    "Very Conservative" => 0.80
    => 0.50

float lowerDotLvl = -upperDotLvl

// ══════════════════════════════════════════════════════════════════════════════
//  TIMEFRAME SCALING CALCULATION
//  Scale periods so all TFs cover the same number of TRADING DAYS as Daily.
//  Uses actual trading hours (6.5h for stocks) not calendar hours (24h).
//  Daily=1x, 4H≈1.6x, 1H=6.5x, 15m=26x, 5m=78x (capped at maxPeriod).
// ══════════════════════════════════════════════════════════════════════════════

int tfSec = timeframe.in_seconds()
float tradingSecsPerDay = tradingHrs * 3600.0

// For daily+ TFs: 1 bar = 1+ trading days, scale down (or stay at 1)
// For intraday TFs: bars per trading day = tradingSecsPerDay / tfSec
float barsPerTradingDay = tfSec >= 86400 ? 1.0 / (float(tfSec) / 86400.0) : tradingSecsPerDay / float(tfSec)
float tfScale = tfAdaptive ? math.max(barsPerTradingDay, 1.0) : 1.0

int effBaseLen  = math.max(math.min(math.round(baseLen * tfScale), maxPeriod), 10)
int effAtrLen   = math.max(math.min(math.round(atrPeriod * tfScale), maxPeriod), 10)

// ══════════════════════════════════════════════════════════════════════════════
//  SOURCE
// ══════════════════════════════════════════════════════════════════════════════

float src = switch srcInput
    "close" => close
    "hlc3"  => hlc3
    "hl2"   => hl2
    "ohlc4" => ohlc4
    => ohlc4

// ══════════════════════════════════════════════════════════════════════════════
//  BASELINE CALCULATION
// ══════════════════════════════════════════════════════════════════════════════

int bLen = math.max(effBaseLen, 2)

// Manual EMA (ta.ema needs simple int; bLen derived from timeframe calcs)
float _emaA = 2.0 / (bLen + 1)
var float _ema = na
_ema := na(_ema[1]) ? src : _emaA * src + (1 - _emaA) * _ema[1]

// EMA of EMA for DEMA/TEMA
var float _e2 = na
_e2 := na(_e2[1]) ? _ema : _emaA * _ema + (1 - _emaA) * _e2[1]
var float _e3 = na
_e3 := na(_e3[1]) ? _e2 : _emaA * _e2 + (1 - _emaA) * _e3[1]

float _sma  = ta.sma(src, bLen)
float _wma  = ta.wma(src, bLen)
float _dema = 2 * _ema - _e2
float _tema = 3 * _ema - 3 * _e2 + _e3

int   hLen  = math.max(math.round(bLen / 2), 1)
int   sqLen = math.max(math.round(math.sqrt(bLen)), 1)
float _hull = ta.wma(2 * ta.wma(src, hLen) - ta.wma(src, bLen), sqLen)

float baseline = switch baseMAType
    "SMA"    => _sma
    "EMA"    => _ema
    "WMA"    => _wma
    "DEMA"   => _dema
    "TEMA"   => _tema
    "HullMA" => _hull
    => _wma

// ══════════════════════════════════════════════════════════════════════════════
//  ATR-NORMALIZED DEVIATION
// ══════════════════════════════════════════════════════════════════════════════

int aLen = math.max(effAtrLen, 2)

// Manual ATR (RMA of true range)
float _tr   = na(close[1]) ? high - low : math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))
float _atrA = 1.0 / aLen
var float atrVal = na
atrVal := na(atrVal[1]) ? _tr : _atrA * _tr + (1 - _atrA) * atrVal[1]

float deviation = src - baseline
float rawZ = atrVal != 0 ? deviation / atrVal : 0.0

// ══════════════════════════════════════════════════════════════════════════════
//  EMA SMOOTHING (fixed bars — NOT scaled by timeframe)
// ══════════════════════════════════════════════════════════════════════════════

int sLen = math.max(smoothLen, 2)
float _smEmaA = 2.0 / (sLen + 1)
var float _smEma = na
_smEma := na(_smEma[1]) ? rawZ : _smEmaA * rawZ + (1 - _smEmaA) * _smEma[1]

float smoothed = smoothLen > 0 ? _smEma : rawZ

// ══════════════════════════════════════════════════════════════════════════════
//  FINAL OUTPUT
// ══════════════════════════════════════════════════════════════════════════════

float oscillator = smoothed * gain + bias

// ══════════════════════════════════════════════════════════════════════════════
//  AUTO-FIT DIAGNOSTIC (optional)
// ══════════════════════════════════════════════════════════════════════════════

float pearsonR = 0.0
float autoGain = gain
float autoBias = bias
float rmse     = 0.0

if showAutoFit
    float _afMeanX = ta.sma(smoothed, corrWindow)
    float _afMeanY = ta.sma(origPlot, corrWindow)
    float _afCov   = ta.sma(smoothed * origPlot, corrWindow) - _afMeanX * _afMeanY
    float _afVarX  = ta.sma(smoothed * smoothed, corrWindow) - _afMeanX * _afMeanX
    float _afVarY  = ta.sma(origPlot * origPlot, corrWindow) - _afMeanY * _afMeanY
    float _afStdX  = math.sqrt(math.max(_afVarX, 0))
    float _afStdY  = math.sqrt(math.max(_afVarY, 0))
    pearsonR := (_afStdX > 0 and _afStdY > 0) ? _afCov / (_afStdX * _afStdY) : 0.0
    autoGain := _afVarX > 0.0001 ? _afCov / _afVarX : 1.0
    autoBias := _afMeanY - autoGain * _afMeanX
    float _err = oscillator - origPlot
    rmse := math.sqrt(ta.sma(_err * _err, corrWindow))

// ══════════════════════════════════════════════════════════════════════════════
//  SIGNAL DOTS (Peak / Trough + Noise Suppression)
// ══════════════════════════════════════════════════════════════════════════════

bool rawPeak   = oscillator[1] > oscillator[2] and oscillator[1] > oscillator[0]
bool rawTrough = oscillator[1] < oscillator[2] and oscillator[1] < oscillator[0]

bool peakAbove   = rawPeak   and oscillator[1] > upperDotLvl
bool troughBelow = rawTrough and oscillator[1] < lowerDotLvl

bool showPeak   = peakAbove
bool showTrough = troughBelow

if noiseSup > 0 and peakAbove
    for i = 2 to noiseSup + 1
        if oscillator[i] > oscillator[1]
            showPeak := false
            break

if noiseSup > 0 and troughBelow
    for i = 2 to noiseSup + 1
        if oscillator[i] < oscillator[1]
            showTrough := false
            break

// ══════════════════════════════════════════════════════════════════════════════
//  PLOTTING
// ══════════════════════════════════════════════════════════════════════════════

plot(oscillator, "Oscillator", color=color.rgb(33, 150, 243), linewidth=2)
plot(showAutoFit and showOrig ? origPlot : na, "Original", color=color.rgb(255, 193, 7), linewidth=1)

plotshape(showPeak   ? oscillator[1] : na, "Sell Signal",  shape.circle, location.absolute, color.rgb(255, 82, 82),  size=size.tiny, offset=-1)
plotshape(showTrough ? oscillator[1] : na, "Buy Signal",   shape.circle, location.absolute, color.rgb(76, 175, 80),  size=size.tiny, offset=-1)

h_upper1 = hline(0.5,  "Upper 1",  color=color.new(color.red, 60),   linestyle=hline.style_dashed)
h_upper2 = hline(0.25, "Upper 2",  color=color.new(color.red, 80),   linestyle=hline.style_dashed)
h_lower2 = hline(-0.25,"Lower 2",  color=color.new(color.green, 80), linestyle=hline.style_dashed)
h_lower1 = hline(-0.5, "Lower 1",  color=color.new(color.green, 60), linestyle=hline.style_dashed)
h_zero   = hline(0,    "Zero",     color=color.new(color.gray, 70),  linestyle=hline.style_dotted)

fill(h_upper2, h_upper1, color=color.new(color.red, 85))
fill(h_lower1, h_lower2, color=color.new(color.green, 85))

// Data window
plot(rawZ,      "Raw Z",     display=display.data_window, color=color.new(color.white, 100))
plot(smoothed,  "Smoothed",  display=display.data_window, color=color.new(color.white, 100))
plot(baseline,  "Baseline",  display=display.data_window, color=color.new(color.white, 100))
plot(atrVal,    "ATR",       display=display.data_window, color=color.new(color.white, 100))

// ══════════════════════════════════════════════════════════════════════════════
//  SETTINGS TABLE
// ══════════════════════════════════════════════════════════════════════════════

var tblPosVal = tblPos == "Top Left" ? position.top_left :
     tblPos == "Top Right" ? position.top_right :
     tblPos == "Bottom Left" ? position.bottom_left :
     position.bottom_right

var table settingsTbl = table.new(tblPosVal, 2, 16,
     bgcolor=color.new(color.black, 30), border_width=1,
     border_color=color.new(color.gray, 60), frame_width=1,
     frame_color=color.new(color.gray, 40))

if barstate.islast and showTable
    table.cell(settingsTbl, 0, 0, "Style",      text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 0, tradingStyle,  text_color=color.white,  text_size=size.small)
    table.cell(settingsTbl, 0, 1, "Base MA",    text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 1, baseMAType + "(" + str.tostring(effBaseLen) + ")", text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 2, "ATR Period", text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 2, str.tostring(effAtrLen), text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 3, "Smooth",     text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 3, smoothLen > 0 ? "EMA(" + str.tostring(smoothLen) + ")" : "None", text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 4, "Source",     text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 4, srcInput,     text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 5, "Gain",       text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 5, str.tostring(gain, "#.####"), text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 6, "Bias",       text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 6, str.tostring(bias, "#.####"), text_color=color.yellow, text_size=size.small)
    table.cell(settingsTbl, 0, 7, "Noise Sup",  text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 7, str.tostring(noiseSup), text_color=color.yellow, text_size=size.small)
    // TF info
    table.cell(settingsTbl, 0, 8, "TF Scale",  text_color=color.gray,   text_size=size.small)
    table.cell(settingsTbl, 1, 8, tfAdaptive ? str.tostring(tfScale, "#.#") + "x" : "OFF", text_color=tfAdaptive ? color.lime : color.gray, text_size=size.small)

    if showAutoFit
        color rColor = pearsonR > 0.95 ? color.lime : pearsonR > 0.85 ? color.yellow : color.red
        table.cell(settingsTbl, 0, 9, "",           text_size=size.small)
        table.cell(settingsTbl, 1, 9, "",           text_size=size.small)
        table.cell(settingsTbl, 0, 10,"Pearson R",  text_color=color.gray, text_size=size.small)
        table.cell(settingsTbl, 1, 10,str.tostring(pearsonR, "#.####"), text_color=rColor, text_size=size.small)
        table.cell(settingsTbl, 0, 11,"RMSE",       text_color=color.gray, text_size=size.small)
        table.cell(settingsTbl, 1, 11,str.tostring(rmse, "#.####"), text_color=color.yellow, text_size=size.small)
        table.cell(settingsTbl, 0, 12,"Sug. Gain",  text_color=color.gray, text_size=size.small)
        table.cell(settingsTbl, 1, 12,str.tostring(autoGain, "#.####"), text_color=color.lime, text_size=size.small)
        table.cell(settingsTbl, 0, 13,"Sug. Bias",  text_color=color.gray, text_size=size.small)
        table.cell(settingsTbl, 1, 13,str.tostring(autoBias, "#.####"), text_color=color.lime, text_size=size.small)
